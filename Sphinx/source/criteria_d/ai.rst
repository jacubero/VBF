******************
Algebraic immunity
******************

Description
===========

A new kind of attacks, called *algebraic attacks*, has been introduced [Courtois:03]_, [CourtoisM:02]_, [FaugereA:03]_. Algebraic attacks recover the secret key, or at least the initialization of the system, by solving a system of multivariate algebraic
equations. A new criterion was introduced in order to identify a cryptographic algorithm's immunity to this kind of attacks.

Denote the Boolean function obtained by the product of the Truth Tables of two Boolean functions :math:`f,g \in \funct{F}_n` by :math:`f \cdot g` (Note that this product is different from the dot product between two vectors :math:`\vec{x},\vec{y}`). The *algebraic immunity (AI)* of *f* is defined as the lowest degree of the function *g* for which :math:`f \cdot g = \vec{0}` or :math:`(\vec{1}+f) \cdot g = \vec{0}`. The function *g* for which :math:`f \cdot g = \vec{0}` is called an *annihilator* of *f*. Denote the set of all annihilators of *f* by :math:`\set{An}(f)`. This set is an ideal in the ring of Boolean functions generated by :math:`\vec{1}+f`. 

A function *f* should not be used if *f* or $1 + f* has a low degree annihilator. If this happens, algebraic attacks [courtois2002cryptanalysis]_ can be executed. 

The component algebraic immunity of any :math:`F \in \funct{F}_{n,m}`, denoted by :math:`\crit{AI}(F)`, is the minimal algebraic immunity of the component functions :math:`\vec{v} \cdot
F (\vec{v})` of the Vector Boolean function with :math:`\vec{v} \neq \vec{0} \in \gf{V_m}`.

The *algebraic attack* exploits the existence of multivariate equations involving the input to the S-box and its output, that is, finding S-boxes with low algebraic immunity.

Library
=======

The method used to obtain this criterion is the following:

.. code-block:: c

	void AI(int& ai, VBF& F)

The method used to the maximum algebraic immunity that can be achieved by a Vector Boolean function with the same number of input bits and output bits is the following:

.. code-block:: c

	int aimax(VBF& F)

Example
-------

The following program provides the algebraic immunity of a Vector Boolean function given its Truth Table.

.. code-block:: c

	#include <iostream>
	#include <fstream>
	#include "VBF.h"

	int main(int argc, char *argv[])
	{
	   using namespace VBFNS;

	   VBF          F;
	   NTL::mat_GF2 T;

	   ifstream input(argv[1]);
	   if(!input) {
	      cerr << "Error opening " << argv[1] << endl;
	      return 0;
	   }
	   input >> T;
	   F.puttt(T);
	   input.close();

	   cout << "The algebraic immunity of the function is " 
	   << AI(F) << endl;
	   cout << "The maximum algebraic immunity that can be achieved by 
	   a Vector Boolean function with the same dimensions is " 
	   << aimax(F) << endl;

	   return 0;
	}

If we use the *NibbleSub* S-box Truth Table as input, the output would be the following:

.. code-block:: console

	The algebraic immunity of the function is 2
	The maximum algebraic immunity that can be achieved by a
	Vector Boolean function with the same dimensions is 2
